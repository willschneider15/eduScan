{"version":3,"file":"Account.mjs","sources":["../../../src/types/Account.ts"],"sourcesContent":["import { Buffer } from 'buffer';\nimport { PublicKey } from '@solana/web3.js';\nimport { SolAmount } from './Amount';\nimport {\n  createSerializerFromSolitaType,\n  deserializeAccount,\n  SolitaType,\n} from './Serializer';\nimport { AccountNotFoundError } from '@/errors';\n\nexport type AccountInfo = {\n  readonly executable: boolean;\n  readonly owner: PublicKey;\n  readonly lamports: SolAmount;\n  readonly rentEpoch?: number;\n};\n\nexport type Account<T> = AccountInfo & {\n  readonly publicKey: PublicKey;\n  readonly data: T;\n};\n\nexport type MaybeAccount<T> =\n  | (Account<T> & { readonly exists: true })\n  | { readonly publicKey: PublicKey; readonly exists: false };\n\nexport type UnparsedAccount = Account<Buffer>;\nexport type UnparsedMaybeAccount = MaybeAccount<Buffer>;\n\nexport type AccountParsingFunction<T> = {\n  (unparsedAccount: UnparsedAccount): Account<T>;\n  (unparsedAccount: UnparsedMaybeAccount): MaybeAccount<T>;\n};\n\nexport type AccountParsingAndAssertingFunction<T> = (\n  unparsedAccount: UnparsedAccount | UnparsedMaybeAccount,\n  solution?: string\n) => Account<T>;\n\nexport function getAccountParsingFunction<T>(\n  parser: SolitaType<T>\n): AccountParsingFunction<T> {\n  function parse(account: UnparsedAccount): Account<T>;\n  function parse(account: UnparsedMaybeAccount): MaybeAccount<T>;\n  function parse(\n    account: UnparsedAccount | UnparsedMaybeAccount\n  ): Account<T> | MaybeAccount<T> {\n    if ('exists' in account && !account.exists) {\n      return account;\n    }\n\n    const serializer = createSerializerFromSolitaType(parser);\n    return deserializeAccount(account, serializer);\n  }\n\n  return parse;\n}\n\nexport function getAccountParsingAndAssertingFunction<T>(\n  parser: SolitaType<T>\n): AccountParsingAndAssertingFunction<T> {\n  const parse = getAccountParsingFunction(parser);\n\n  return (\n    unparsedAccount: UnparsedAccount | UnparsedMaybeAccount,\n    solution?: string\n  ) => {\n    if ('exists' in unparsedAccount) {\n      assertAccountExists(unparsedAccount, parser.name, solution);\n    }\n\n    return parse(unparsedAccount);\n  };\n}\n\nexport function assertAccountExists<T>(\n  account: MaybeAccount<T>,\n  name?: string,\n  solution?: string\n): asserts account is Account<T> & { exists: true } {\n  if (!account.exists) {\n    throw new AccountNotFoundError(account.publicKey, name, solution);\n  }\n}\n\nexport const toAccountInfo = (account: UnparsedAccount): AccountInfo => {\n  const { executable, owner, lamports, rentEpoch } = account;\n  return { executable, owner, lamports, rentEpoch };\n};\n"],"names":["getAccountParsingFunction","parser","parse","account","exists","serializer","createSerializerFromSolitaType","deserializeAccount","getAccountParsingAndAssertingFunction","unparsedAccount","solution","assertAccountExists","name","AccountNotFoundError","publicKey","toAccountInfo","executable","owner","lamports","rentEpoch"],"mappings":";;;AAuCO,SAASA,yBAAyB,CACvCC,MAAqB,EACM;EAG3B,SAASC,KAAK,CACZC,OAA+C,EACjB;IAC9B,IAAI,QAAQ,IAAIA,OAAO,IAAI,CAACA,OAAO,CAACC,MAAM,EAAE;AAC1C,MAAA,OAAOD,OAAO,CAAA;AAChB,KAAA;AAEA,IAAA,MAAME,UAAU,GAAGC,8BAA8B,CAACL,MAAM,CAAC,CAAA;AACzD,IAAA,OAAOM,kBAAkB,CAACJ,OAAO,EAAEE,UAAU,CAAC,CAAA;AAChD,GAAA;AAEA,EAAA,OAAOH,KAAK,CAAA;AACd,CAAA;AAEO,SAASM,qCAAqC,CACnDP,MAAqB,EACkB;AACvC,EAAA,MAAMC,KAAK,GAAGF,yBAAyB,CAACC,MAAM,CAAC,CAAA;AAE/C,EAAA,OAAO,CACLQ,eAAuD,EACvDC,QAAiB,KACd;IACH,IAAI,QAAQ,IAAID,eAAe,EAAE;MAC/BE,mBAAmB,CAACF,eAAe,EAAER,MAAM,CAACW,IAAI,EAAEF,QAAQ,CAAC,CAAA;AAC7D,KAAA;IAEA,OAAOR,KAAK,CAACO,eAAe,CAAC,CAAA;GAC9B,CAAA;AACH,CAAA;AAEO,SAASE,mBAAmB,CACjCR,OAAwB,EACxBS,IAAa,EACbF,QAAiB,EACiC;AAClD,EAAA,IAAI,CAACP,OAAO,CAACC,MAAM,EAAE;IACnB,MAAM,IAAIS,oBAAoB,CAACV,OAAO,CAACW,SAAS,EAAEF,IAAI,EAAEF,QAAQ,CAAC,CAAA;AACnE,GAAA;AACF,CAAA;AAEaK,MAAAA,aAAa,GAAIZ,OAAwB,IAAkB;EACtE,MAAM;IAAEa,UAAU;IAAEC,KAAK;IAAEC,QAAQ;AAAEC,IAAAA,SAAAA;AAAU,GAAC,GAAGhB,OAAO,CAAA;EAC1D,OAAO;IAAEa,UAAU;IAAEC,KAAK;IAAEC,QAAQ;AAAEC,IAAAA,SAAAA;GAAW,CAAA;AACnD;;;;"}