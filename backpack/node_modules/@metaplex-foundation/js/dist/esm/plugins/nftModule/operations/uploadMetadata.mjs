import cloneDeep from 'lodash.clonedeep';
import { walk } from '../../../utils/common.mjs';
import { isMetaplexFile } from '../../storageModule/MetaplexFile.mjs';
import { useOperation } from '../../../types/Operation.mjs';

// -----------------
// Operation
// -----------------

const Key = 'UploadMetadataOperation';

/**
 * Uploads a JSON Metadata object to the current storage provider.
 *
 * ```ts
 * const { uri } = await metaplex
 *   .nfts()
 *   .uploadMetadata({
 *     name: "My NFT",
 *     description: "My description",
 *     image: "https://arweave.net/123",
 *   };
 * ```
 *
 * @group Operations
 * @category Constructors
 */
const uploadMetadataOperation = useOperation(Key);

/**
 * @group Operations
 * @category Types
 */

/**
 * @group Operations
 * @category Handlers
 */
const uploadMetadataOperationHandler = {
  handle: async (operation, metaplex, scope) => {
    const rawMetadata = operation.input;
    const files = getAssetsFromJsonMetadata(rawMetadata);
    const assetUris = await metaplex.storage().uploadAll(files);
    scope.throwIfCanceled();
    const metadata = replaceAssetsWithUris(rawMetadata, assetUris);
    const uri = await metaplex.storage().uploadJson(metadata);
    return {
      uri,
      metadata,
      assetUris
    };
  }
};
const getAssetsFromJsonMetadata = input => {
  const files = [];
  walk(input, (next, value) => {
    if (isMetaplexFile(value)) {
      files.push(value);
    } else {
      next(value);
    }
  });
  return files;
};
const replaceAssetsWithUris = (input, replacements) => {
  const clone = cloneDeep(input);
  let index = 0;
  walk(clone, (next, value, key, parent) => {
    if (isMetaplexFile(value)) {
      if (index < replacements.length) {
        parent[key] = replacements[index++];
      }
    } else {
      next(value);
    }
  });
  return clone;
};

export { getAssetsFromJsonMetadata, replaceAssetsWithUris, uploadMetadataOperation, uploadMetadataOperationHandler };
//# sourceMappingURL=uploadMetadata.mjs.map
