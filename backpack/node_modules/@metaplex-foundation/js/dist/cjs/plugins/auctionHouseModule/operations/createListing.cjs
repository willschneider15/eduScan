'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var mplAuctionHouse = require('@metaplex-foundation/mpl-auction-house');
var web3_js = require('@solana/web3.js');
var constants = require('../constants.cjs');
var errors = require('../errors.cjs');
var Operation = require('../../../types/Operation.cjs');
var DateTime = require('../../../types/DateTime.cjs');
var Amount = require('../../../types/Amount.cjs');
var Signer = require('../../../types/Signer.cjs');
var PublicKey = require('../../../types/PublicKey.cjs');
var TransactionBuilder = require('../../../utils/TransactionBuilder.cjs');

// -----------------
// Operation
// -----------------

const Key = 'CreateListingOperation';

/**
 * Creates a listing on a given asset.
 *
 * ```ts
 * await metaplex
 *   .auctionHouse()
 *   .createListing({ auctionHouse, mintAccount };
 * ```
 *
 * @group Operations
 * @category Constructors
 */
const createListingOperation = Operation.useOperation(Key);

/**
 * @group Operations
 * @category Types
 */

/**
 * @group Operations
 * @category Handlers
 */
const createListingOperationHandler = {
  async handle(operation, metaplex, scope) {
    const {
      auctionHouse
    } = operation.input;
    const builder = createListingBuilder(metaplex, operation.input, scope);
    const confirmOptions = Operation.makeConfirmOptionsFinalizedOnMainnet(metaplex, scope.confirmOptions);
    const output = await builder.sendAndConfirm(metaplex, confirmOptions);
    scope.throwIfCanceled();
    if (output.receipt) {
      const listing = await metaplex.auctionHouse().findListingByReceipt({
        receiptAddress: output.receipt,
        auctionHouse
      }, scope);
      return {
        listing,
        ...output
      };
    }
    scope.throwIfCanceled();
    const lazyListing = {
      model: 'listing',
      lazy: true,
      auctionHouse,
      tradeStateAddress: output.sellerTradeState,
      bookkeeperAddress: output.bookkeeper,
      sellerAddress: output.seller,
      metadataAddress: output.metadata,
      receiptAddress: output.receipt,
      purchaseReceiptAddress: null,
      price: output.price,
      tokens: output.tokens.basisPoints,
      createdAt: DateTime.now(),
      canceledAt: null
    };
    return {
      listing: await metaplex.auctionHouse().loadListing({
        lazyListing
      }, scope),
      ...output
    };
  }
};

// -----------------
// Builder
// -----------------

/**
 * Creates a listing on a given asset.
 *
 * ```ts
 * const transactionBuilder = metaplex
 *   .auctionHouse()
 *   .builders()
 *   .createListing({ auctionHouse, mintAccount });
 * ```
 *
 * @group Transaction Builders
 * @category Constructors
 */

/**
 * @group Transaction Builders
 * @category Constructors
 */
const createListingBuilder = (metaplex, params, options = {}) => {
  const {
    programs,
    payer = metaplex.rpc().getDefaultFeePayer()
  } = options;
  const {
    auctionHouse,
    auctioneerAuthority,
    mintAccount,
    tokens = Amount.token(1),
    seller = metaplex.identity(),
    authority = auctionHouse.authorityAddress
  } = params;

  // Data.
  const priceBasisPoint = auctioneerAuthority ? constants.AUCTIONEER_PRICE : params.price?.basisPoints ?? 0;
  const price = auctionHouse.isNative ? Amount.lamports(priceBasisPoint) : Amount.amount(priceBasisPoint, auctionHouse.treasuryMint.currency);
  if (auctionHouse.hasAuctioneer && !auctioneerAuthority) {
    throw new errors.AuctioneerAuthorityRequiredError();
  }
  if (!Signer.isSigner(seller) && !Signer.isSigner(authority)) {
    throw new errors.CreateListingRequiresSignerError();
  }

  // Accounts.
  const metadata = metaplex.nfts().pdas().metadata({
    mint: mintAccount,
    programs
  });
  const tokenAccount = params.tokenAccount ?? metaplex.tokens().pdas().associatedTokenAccount({
    mint: mintAccount,
    owner: PublicKey.toPublicKey(seller),
    programs
  });
  const sellerTradeState = metaplex.auctionHouse().pdas().tradeState({
    auctionHouse: auctionHouse.address,
    wallet: PublicKey.toPublicKey(seller),
    treasuryMint: auctionHouse.treasuryMint.address,
    tokenMint: mintAccount,
    price: price.basisPoints,
    tokenSize: tokens.basisPoints,
    tokenAccount,
    programs
  });
  const freeSellerTradeState = metaplex.auctionHouse().pdas().tradeState({
    auctionHouse: auctionHouse.address,
    wallet: PublicKey.toPublicKey(seller),
    treasuryMint: auctionHouse.treasuryMint.address,
    tokenMint: mintAccount,
    price: Amount.lamports(0).basisPoints,
    tokenSize: tokens.basisPoints,
    tokenAccount,
    programs
  });
  const programAsSigner = metaplex.auctionHouse().pdas().programAsSigner({
    programs
  });
  const accounts = {
    wallet: PublicKey.toPublicKey(seller),
    tokenAccount,
    metadata,
    authority: PublicKey.toPublicKey(authority),
    auctionHouse: auctionHouse.address,
    auctionHouseFeeAccount: auctionHouse.feeAccountAddress,
    sellerTradeState,
    freeSellerTradeState,
    programAsSigner
  };

  // Args.
  const args = {
    tradeStateBump: sellerTradeState.bump,
    freeTradeStateBump: freeSellerTradeState.bump,
    programAsSignerBump: programAsSigner.bump,
    buyerPrice: price.basisPoints,
    tokenSize: tokens.basisPoints
  };

  // Sell Instruction.
  let sellInstruction = mplAuctionHouse.createSellInstruction(accounts, args);
  if (auctioneerAuthority) {
    sellInstruction = mplAuctionHouse.createAuctioneerSellInstruction({
      ...accounts,
      auctioneerAuthority: auctioneerAuthority.publicKey,
      ahAuctioneerPda: metaplex.auctionHouse().pdas().auctioneer({
        auctionHouse: auctionHouse.address,
        auctioneerAuthority: auctioneerAuthority.publicKey,
        programs
      })
    }, args);
  }

  // Signers.
  const signer = Signer.isSigner(seller) ? seller : authority;
  const sellSigners = [signer, auctioneerAuthority].filter(Signer.isSigner);

  // Update the account to be a signer since it's not covered properly by MPL due to its dynamic nature.
  const signerKeyIndex = sellInstruction.keys.findIndex(key => key.pubkey.equals(signer.publicKey));
  sellInstruction.keys[signerKeyIndex].isSigner = true;

  // Fixes cross-program invocation with unauthorized writable account
  if (sellInstruction.keys[signerKeyIndex].pubkey.equals(PublicKey.toPublicKey(seller))) {
    sellInstruction.keys[signerKeyIndex].isWritable = true;
  }

  // Receipt.
  // Since createPrintListingReceiptInstruction can't deserialize createAuctioneerSellInstruction due to a bug
  // Don't print Auctioneer Sell receipt for the time being.
  const shouldPrintReceipt = (params.printReceipt ?? true) && !auctioneerAuthority;
  const bookkeeper = params.bookkeeper ?? metaplex.identity();
  const receipt = metaplex.auctionHouse().pdas().listingReceipt({
    tradeState: sellerTradeState,
    programs
  });
  return TransactionBuilder.TransactionBuilder.make().setFeePayer(payer).setContext({
    sellerTradeState,
    freeSellerTradeState,
    tokenAccount,
    metadata,
    seller: PublicKey.toPublicKey(seller),
    receipt: shouldPrintReceipt ? receipt : null,
    bookkeeper: shouldPrintReceipt ? bookkeeper.publicKey : null,
    price,
    tokens
  })

  // Create Listing.
  .add({
    instruction: sellInstruction,
    signers: sellSigners,
    key: 'sell'
  })

  // Print the Listing Receipt.
  .when(shouldPrintReceipt, builder => builder.add({
    instruction: mplAuctionHouse.createPrintListingReceiptInstruction({
      receipt,
      bookkeeper: bookkeeper.publicKey,
      instruction: web3_js.SYSVAR_INSTRUCTIONS_PUBKEY
    }, {
      receiptBump: receipt.bump
    }),
    signers: [bookkeeper],
    key: 'printListingReceipt'
  }));
};

exports.createListingBuilder = createListingBuilder;
exports.createListingOperation = createListingOperation;
exports.createListingOperationHandler = createListingOperationHandler;
//# sourceMappingURL=createListing.cjs.map
