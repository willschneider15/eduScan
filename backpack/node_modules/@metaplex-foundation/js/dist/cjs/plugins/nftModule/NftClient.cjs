'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var helpers = require('./helpers.cjs');
var NftBuildersClient = require('./NftBuildersClient.cjs');
var NftPdasClient = require('./NftPdasClient.cjs');
var findNftByMint = require('./operations/findNftByMint.cjs');
var findNftByMetadata = require('./operations/findNftByMetadata.cjs');
var findNftByToken = require('./operations/findNftByToken.cjs');
var findNftsByCreator = require('./operations/findNftsByCreator.cjs');
var findNftsByMintList = require('./operations/findNftsByMintList.cjs');
var findNftsByOwner = require('./operations/findNftsByOwner.cjs');
var findNftsByUpdateAuthority = require('./operations/findNftsByUpdateAuthority.cjs');
var loadMetadata = require('./operations/loadMetadata.cjs');
var createNft = require('./operations/createNft.cjs');
var createSft = require('./operations/createSft.cjs');
var printNewEdition = require('./operations/printNewEdition.cjs');
var uploadMetadata = require('./operations/uploadMetadata.cjs');
var updateNft = require('./operations/updateNft.cjs');
var deleteNft = require('./operations/deleteNft.cjs');
var useNft = require('./operations/useNft.cjs');
var approveNftUseAuthority = require('./operations/approveNftUseAuthority.cjs');
var revokeNftUseAuthority = require('./operations/revokeNftUseAuthority.cjs');
var verifyNftCreator = require('./operations/verifyNftCreator.cjs');
var unverifyNftCreator = require('./operations/unverifyNftCreator.cjs');
var verifyNftCollection = require('./operations/verifyNftCollection.cjs');
var unverifyNftCollection = require('./operations/unverifyNftCollection.cjs');
var approveNftCollectionAuthority = require('./operations/approveNftCollectionAuthority.cjs');
var revokeNftCollectionAuthority = require('./operations/revokeNftCollectionAuthority.cjs');
var migrateToSizedCollectionNft = require('./operations/migrateToSizedCollectionNft.cjs');
var freezeDelegatedNft = require('./operations/freezeDelegatedNft.cjs');
var thawDelegatedNft = require('./operations/thawDelegatedNft.cjs');
var Amount = require('../../types/Amount.cjs');

/**
 * This is a client for the NFT module.
 *
 * It enables us to interact with the Token Metadata program in order to
 * manage NFTs and SFTs.
 *
 * You may access this client via the `nfts()` method of your `Metaplex` instance.
 *
 * ```ts
 * const nftClient = metaplex.nfts();
 * ```
 *
 * @example
 * You can upload some custom JSON metadata and use its URI to create
 * a new NFT like so. The owner and update authority of this NFT will,
 * by default, be the current identity of the metaplex instance.
 *
 * ```ts
 * const { uri } = await metaplex
 *   .nfts()
 *   .uploadMetadata({
 *     name: "My off-chain name",
 *     description: "My off-chain description",
 *     image: "https://arweave.net/123",
 *   };
 *
 * const { nft } = await metaplex
 *   .nfts()
 *   .create({
 *     uri,
 *     name: 'My on-chain NFT',
 *     sellerFeeBasisPoints: 250, // 2.5%
 *   };
 * ```
 *
 * @group Modules
 */
class NftClient {
  constructor(metaplex) {
    this.metaplex = metaplex;
  }

  /**
   * You may use the `builders()` client to access the
   * underlying Transaction Builders of this module.
   *
   * ```ts
   * const buildersClient = metaplex.nfts().builders();
   * ```
   */
  builders() {
    return new NftBuildersClient.NftBuildersClient(this.metaplex);
  }

  /**
   * You may use the `pdas()` client to build PDAs related to this module.
   *
   * ```ts
   * const pdasClient = metaplex.nfts().pdas();
   * ```
   */
  pdas() {
    return new NftPdasClient.NftPdasClient(this.metaplex);
  }

  // -----------------
  // Queries
  // -----------------

  /** {@inheritDoc findNftByMintOperation} */
  findByMint(input, options) {
    return this.metaplex.operations().execute(findNftByMint.findNftByMintOperation(input), options);
  }

  /** {@inheritDoc findNftByMetadataOperation} */
  findByMetadata(input, options) {
    return this.metaplex.operations().execute(findNftByMetadata.findNftByMetadataOperation(input), options);
  }

  /** {@inheritDoc findNftByTokenOperation} */
  findByToken(input, options) {
    return this.metaplex.operations().execute(findNftByToken.findNftByTokenOperation(input), options);
  }

  /** {@inheritDoc findNftsByCreatorOperation} */
  findAllByCreator(input, options) {
    return this.metaplex.operations().execute(findNftsByCreator.findNftsByCreatorOperation(input), options);
  }

  /** {@inheritDoc findNftsByMintListOperation} */
  findAllByMintList(input, options) {
    return this.metaplex.operations().execute(findNftsByMintList.findNftsByMintListOperation(input), options);
  }

  /** {@inheritDoc findNftsByOwnerOperation} */
  findAllByOwner(input, options) {
    return this.metaplex.operations().execute(findNftsByOwner.findNftsByOwnerOperation(input), options);
  }

  /** {@inheritDoc findNftsByUpdateAuthorityOperation} */
  findAllByUpdateAuthority(input, options) {
    return this.metaplex.operations().execute(findNftsByUpdateAuthority.findNftsByUpdateAuthorityOperation(input), options);
  }

  /** {@inheritDoc loadMetadataOperation} */
  load(input, options) {
    return this.metaplex.operations().execute(loadMetadata.loadMetadataOperation(input), options);
  }

  /**
   * Helper method that refetches a given model
   * and returns an instance of the same type.
   *
   * ```ts
   * nft = await metaplex.nfts().refresh(nft);
   * sft = await metaplex.nfts().refresh(sft);
   * nftWithToken = await metaplex.nfts().refresh(nftWithToken);
   * ```
   */
  refresh(model, input, options) {
    return this.findByMint({
      mintAddress: helpers.toMintAddress(model),
      tokenAddress: 'token' in model ? model.token.address : undefined,
      ...input
    }, options);
  }

  // -----------------
  // Create, Update and Delete
  // -----------------

  /** {@inheritDoc createNftOperation} */
  create(input, options) {
    return this.metaplex.operations().execute(createNft.createNftOperation(input), options);
  }

  /** {@inheritDoc createSftOperation} */
  createSft(input, options) {
    return this.metaplex.operations().execute(createSft.createSftOperation(input), options);
  }

  /** {@inheritDoc printNewEditionOperation} */
  printNewEdition(input, options) {
    return this.metaplex.operations().execute(printNewEdition.printNewEditionOperation(input), options);
  }

  /** {@inheritDoc uploadMetadataOperation} */
  uploadMetadata(input, options) {
    return this.metaplex.operations().execute(uploadMetadata.uploadMetadataOperation(input), options);
  }

  /** {@inheritDoc updateNftOperation} */
  update(input, options) {
    return this.metaplex.operations().execute(updateNft.updateNftOperation(input), options);
  }

  /** {@inheritDoc deleteNftOperation} */
  delete(input, options) {
    return this.metaplex.operations().execute(deleteNft.deleteNftOperation(input), options);
  }

  // -----------------
  // Use
  // -----------------

  /** {@inheritDoc useNftOperation} */
  use(input, options) {
    return this.metaplex.operations().execute(useNft.useNftOperation(input), options);
  }

  /** {@inheritDoc approveNftUseAuthorityOperation} */
  approveUseAuthority(input, options) {
    return this.metaplex.operations().execute(approveNftUseAuthority.approveNftUseAuthorityOperation(input), options);
  }

  /** {@inheritDoc revokeNftUseAuthorityOperation} */
  revokeUseAuthority(input, options) {
    return this.metaplex.operations().execute(revokeNftUseAuthority.revokeNftUseAuthorityOperation(input), options);
  }

  // -----------------
  // Creators
  // -----------------

  /** {@inheritDoc verifyNftCreatorOperation} */
  verifyCreator(input, options) {
    return this.metaplex.operations().execute(verifyNftCreator.verifyNftCreatorOperation(input), options);
  }

  /** {@inheritDoc unverifyNftCreatorOperation} */
  unverifyCreator(input, options) {
    return this.metaplex.operations().execute(unverifyNftCreator.unverifyNftCreatorOperation(input), options);
  }

  // -----------------
  // Collections
  // -----------------

  /** {@inheritDoc verifyNftCollectionOperation} */
  verifyCollection(input, options) {
    return this.metaplex.operations().execute(verifyNftCollection.verifyNftCollectionOperation(input), options);
  }

  /** {@inheritDoc unverifyNftCollectionOperation} */
  unverifyCollection(input, options) {
    return this.metaplex.operations().execute(unverifyNftCollection.unverifyNftCollectionOperation(input), options);
  }

  /** {@inheritDoc approveNftCollectionAuthorityOperation} */
  approveCollectionAuthority(input, options) {
    return this.metaplex.operations().execute(approveNftCollectionAuthority.approveNftCollectionAuthorityOperation(input), options);
  }

  /** {@inheritDoc revokeNftCollectionAuthorityOperation} */
  revokeCollectionAuthority(input, options) {
    return this.metaplex.operations().execute(revokeNftCollectionAuthority.revokeNftCollectionAuthorityOperation(input), options);
  }

  /** {@inheritDoc migrateToSizedCollectionNftOperation} */
  migrateToSizedCollection(input, options) {
    return this.metaplex.operations().execute(migrateToSizedCollectionNft.migrateToSizedCollectionNftOperation(input), options);
  }

  // -----------------
  // Tokens
  // -----------------

  /** {@inheritDoc freezeDelegatedNftOperation} */
  freezeDelegatedNft(input, options) {
    return this.metaplex.operations().execute(freezeDelegatedNft.freezeDelegatedNftOperation(input), options);
  }

  /** {@inheritDoc thawDelegatedNftOperation} */
  thawDelegatedNft(input, options) {
    return this.metaplex.operations().execute(thawDelegatedNft.thawDelegatedNftOperation(input), options);
  }

  /** {@inheritDoc sendTokensOperation} */
  send(input, options) {
    // TODO: update documentation.
    return this.metaplex.tokens().send({
      ...input,
      amount: Amount.token(1)
    }, options);
  }
}

exports.NftClient = NftClient;
//# sourceMappingURL=NftClient.cjs.map
