'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _rollupPluginBabelHelpers = require('../../_virtual/_rollupPluginBabelHelpers.cjs');
var Amount = require('../../types/Amount.cjs');

const TRANSACTION_FEE = 5000;

/**
 * @group Modules
 */
class UtilsClient {
  constructor(metaplex) {
    _rollupPluginBabelHelpers.defineProperty(this, "cachedRentPerEmptyAccount", null);
    _rollupPluginBabelHelpers.defineProperty(this, "cachedRentPerByte", null);
    this.metaplex = metaplex;
  }
  async estimate(bytes, numberOfAccounts = 1, numberOfTransactions = 1, useCache = true) {
    const rent = await this.estimateRent(bytes, numberOfAccounts, useCache);
    const transactionFees = this.estimateTransactionFee(numberOfTransactions);
    return Amount.addAmounts(rent, transactionFees);
  }
  async estimateRent(bytes, numberOfAccounts = 1, useCache = true) {
    if (!useCache || this.cachedRentPerEmptyAccount === null || this.cachedRentPerByte === null) {
      const rentFor0Bytes = await this.metaplex.rpc().getRent(0);

      // TODO(loris): Infer from header size in bytes.
      const rentFor1Byte = await this.metaplex.rpc().getRent(1);
      this.cachedRentPerEmptyAccount = rentFor0Bytes;
      this.cachedRentPerByte = Amount.subtractAmounts(rentFor1Byte, rentFor0Bytes);
    }
    const rentForAccounts = Amount.multiplyAmount(this.cachedRentPerEmptyAccount, numberOfAccounts);
    const rentForBytes = Amount.multiplyAmount(this.cachedRentPerByte, bytes);
    return Amount.addAmounts(rentForAccounts, rentForBytes);
  }
  estimateTransactionFee(numberOfTransactions = 1) {
    // TODO(loris): Improve with an RPC call to get the current transaction fee.
    return Amount.lamports(numberOfTransactions * TRANSACTION_FEE);
  }
}

exports.UtilsClient = UtilsClient;
//# sourceMappingURL=UtilsClient.cjs.map
